<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kinderrr BLOG</title>
  
  <subtitle>no zuo no die</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-11T12:44:48.846Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Kinder</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>websocket</title>
    <link href="http://example.com/posts/3emd.html"/>
    <id>http://example.com/posts/3emd.html</id>
    <published>2022-11-03T15:01:17.129Z</published>
    <updated>2023-08-11T12:44:48.846Z</updated>
    
    <content type="html"><![CDATA[<p><img src="C:\Users\Kinder2003\AppData\Roaming\Typora\typora-user-images\image-20221103230248111.png" alt="image-20221103230248111"></p><ul><li><h3 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a><strong>消息格式</strong></h3><ul><li><p>客户端 ——服务端</p><p>​                                                    {“toName”:”张三”  ，”message”:brabra}</p></li><li><p>服务端——客户端</p><ul><li>基本格式</li><li><img src="C:\Users\Kinder2003\AppData\Roaming\Typora\typora-user-images\image-20221103230537086.png" alt="image-20221103230537086"></li></ul></li></ul></li></ul><h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a><strong>功能实现</strong></h3><blockquote><p>​    参考:<a href="https://blog.csdn.net/moshowgame/article/details/80275084?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166748714216782425664597%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166748714216782425664597&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80275084-null-null.142^v63^control,201^v3^control_1,213^v1^control&amp;utm_term=websocket&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/moshowgame/article/details/80275084?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166748714216782425664597%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166748714216782425664597&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80275084-null-null.142^v63^control,201^v3^control_1,213^v1^control&amp;utm_term=websocket&amp;spm=1018.2226.3001.4187</a></p></blockquote><ol><li><p>创建项目</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li><p>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageUtils</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMessage</span><span class="params">(<span class="type">boolean</span> isSystemMessage,String fromName,Object message)</span>&#123;</span><br><span class="line">        ResultMessage result= <span class="keyword">new</span> <span class="title class_">ResultMessage</span>();</span><br><span class="line">        result.setIsSystem(isSystemMessage);</span><br><span class="line">        result.setMessage(message);</span><br><span class="line">        <span class="keyword">if</span>(fromName!=<span class="literal">null</span>)&#123;</span><br><span class="line">            result.setFromName(fromName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="keyword">return</span> mapper.writeValueAsString(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;C:\Users\Kinder2003\AppData\Roaming\Typora\typora-user-images\image-20221103230248111.png&quot; alt=&quot;image-20221103230248111&quot;&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>go语言学习</title>
    <link href="http://example.com/posts/3dsd.html"/>
    <id>http://example.com/posts/3dsd.html</id>
    <published>2022-10-27T09:26:12.000Z</published>
    <updated>2023-08-11T12:44:31.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言基础"><a href="#Go语言基础" class="headerlink" title="Go语言基础"></a>Go语言基础</h2><h3 id="1-Go语言的出现"><a href="#1-Go语言的出现" class="headerlink" title="1. Go语言的出现"></a>1. Go语言的出现</h3><p>​    在具体学习go语言的基础语法之前，我们来了解一下go语言出现的时机及其特点。</p><p>​    Go语言最初由Google公司的Robert Griesemer、Ken Thompson和Rob Pike三个大牛于2007年开始设计发明，他们最终的目标是设计一种适应网络和多核时代的C语言。所以Go语言很多时候被描述为“类C语言”，或者是“21世纪的C语言”，当然从各种角度看，Go语言确实是从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等诸多编程思想。但是Go语言更是对C语言最彻底的一次扬弃，它舍弃了C语言中灵活但是危险的指针运算，还重新设计了C语言中部分不太合理运算符的优先级，并在很多细微的地方都做了必要的打磨和改变。</p><h3 id="2-Go版本的Hello-World"><a href="#2-Go版本的Hello-World" class="headerlink" title="2. Go版本的Hello World"></a>2. Go版本的Hello World</h3><p><img src="https://cdn.kaison.top/img/blog/20230731230059.png" alt="image-20230731230057471"></p><p>和C语言类似</p><h4 id="go语言的基本组成"><a href="#go语言的基本组成" class="headerlink" title="go语言的基本组成"></a>go语言的基本组成</h4><pre><code>- 包声名 package main- 引入包 import &quot;fmt&quot;- 函数 - 变量 可以由字母、数字、下划线，但开头不能为数字- 语句/表达式，一行代表一个语句结束- 注释 //  /**/</code></pre><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h3><h4 id="3-1-基本数据类型"><a href="#3-1-基本数据类型" class="headerlink" title="3.1 基本数据类型"></a>3.1 基本数据类型</h4><p><img src="https://cdn.kaison.top/img/blog/20230731232032.png" alt="image-20230731232031659"></p><h4 id="3-2-定义变量"><a href="#3-2-定义变量" class="headerlink" title="3.2 定义变量"></a>3.2 定义变量</h4><p>格式为var identifier typename</p><h5 id="如果变量没有初始化"><a href="#如果变量没有初始化" class="headerlink" title="如果变量没有初始化"></a><strong>如果变量没有初始化</strong></h5><p>在go语言中定义了一个变量，指定变量类型，如果没有初始化，则变量默认为零值。<strong>零值就是变量没有做初始化时系统默认设置的值</strong>。</p><div class="table-container"><table><thead><tr><th>类型</th><th>零值</th></tr></thead><tbody><tr><td>数值类型</td><td>0</td></tr><tr><td>布尔类型</td><td>false</td></tr><tr><td>字符串</td><td>“”（空字符串）</td></tr></tbody></table></div><h5 id="如果变量没有指定类型"><a href="#如果变量没有指定类型" class="headerlink" title="如果变量没有指定类型"></a>如果变量没有指定类型</h5><p>在go语言中没有指定类型，可以通过变量初始值来判断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="literal">true</span>;</span><br><span class="line">    fmt.Println(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="符号"><a href="#符号" class="headerlink" title=":= 符号"></a>:= 符号</h5><p>声明语句 相对于构造器，只能用一次</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typename := value</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> intVal := <span class="number">1</span></span><br><span class="line">intVal = <span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="多变量声名"><a href="#多变量声名" class="headerlink" title="多变量声名"></a>多变量声名</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x,y <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> c,d <span class="type">int</span> = <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">g,h := <span class="number">123</span>,<span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">a <span class="type">int</span></span><br><span class="line">    b <span class="type">bool</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h5><p>在变量声明的时候使用下划线代替即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">()</span></span>(<span class="type">int</span> ,<span class="type">int</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>,<span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a, _ :=GetData()</span><br><span class="line">    _, b :=GetData()</span><br><span class="line">    fmt.Println(a,b)</span><br><span class="line">&#125;<span class="comment">//匿名变量不占用内存空间</span></span><br></pre></td></tr></table></figure><p>变量作用域</p><p>作用域指的是已声明的标识符所表示的常量、类型、函数或者包在源代码中的作用范围，在此我们主要看一下go中变量的作用域，根据变量定义位置的不同，可以分为一下三个类型：</p><pre><code>函数内定义的变量为局部变量，这种局部变量的作用域只在函数体内，函数的参数和返回值变量都属于局部变量。这种变量在存在于函数被调用时，销毁于函数调用结束后。函数外定义的变量为全局变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，甚至可以使用import引入外部包来使用。全局变量声明必须以 var 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。函数定义中的变量成为形式参数，定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。形式参数会作为函数的局部变量来使用。</code></pre><h4 id="3-3-基本类型"><a href="#3-3-基本类型" class="headerlink" title="3.3 基本类型"></a>3.3 基本类型</h4><p><img src="https://cdn.kaison.top/img/blog/20230801000633.png" alt="image-20230801000632419"></p><h4 id="3-4-指针"><a href="#3-4-指针" class="headerlink" title="3.4 指针"></a>3.4 指针</h4><p>Go语言中的取地址符&amp;，放到一个变量前取其地址</p><h5 id="3-4-1-指针声明和优化"><a href="#3-4-1-指针声明和优化" class="headerlink" title="3.4.1 指针声明和优化"></a>3.4.1 指针声明和优化</h5><p>​    和基础类型数据相同，在使用指针变量之前我们首先需要声明指针 var var_name *var_type</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span>= <span class="number">20</span>   <span class="comment">/* 声明实际变量 */</span></span><br><span class="line"><span class="keyword">var</span> ip *<span class="type">int</span>        <span class="comment">/* 声明指针变量 */</span></span><br><span class="line"></span><br><span class="line">ip = &amp;a  <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-4-2-空指针"><a href="#3-4-2-空指针" class="headerlink" title="3.4.2 空指针"></a>3.4.2 空指针</h5><p>​    值为nil，没有分配任何变量</p><h5 id="3-4-3-数组"><a href="#3-4-3-数组" class="headerlink" title="3.4.3 数组"></a>3.4.3 数组</h5><p>​    和c语言相通，数组是具有相同唯一类型的一组以编号且长度固定的数据项序列</p><h6 id="3-4-3-1-数组声明"><a href="#3-4-3-1-数组声明" class="headerlink" title="3.4.3.1 数组声明"></a>3.4.3.1 数组声明</h6><p>​    Go的语法如下</p><pre><code>  var variable_name[size] variable_TYPE</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> balance [<span class="number">10</span>] <span class="type">float32</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="3-4-3-2-初始化数组"><a href="#3-4-3-2-初始化数组" class="headerlink" title="3.4.3.2 初始化数组"></a>3.4.3.2 初始化数组</h6><p>数组初始化有几种</p><ol><li><p>直接进行初始化：<code>var balance = [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></p></li><li><p>通过字面量在声明数组的同时快速初始化数组：<code>balance := [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></p></li><li><p>数组长度不确定，编译器通过元素个数自行推断数组长度，在[ ]中填入…，举例如下：var balance = […]float32{1000.0, 2.0, 3.4, 7.0, 50.0}和balance := […]float32{1000.0, 2.0, 3.4, 7.0, 50.0}</p></li><li><p>数组长度确定，指定下标进行部分初始化：<code>balanced := [5]float32(1:2.0, 3:7.0)</code></p><h6 id="3-4-3-3数组指针"><a href="#3-4-3-3数组指针" class="headerlink" title="3.4.3.3数组指针"></a>3.4.3.3数组指针</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// a 是一个数组</span></span><br><span class="line"><span class="keyword">var</span> b = &amp;a                <span class="comment">// b 是指向数组的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组指针除了可以防止数组作为参数传递的时候浪费空间，还可以利用其和for range来遍历数组，具体代码如下：</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> b &#123;     <span class="comment">// 通过数组指针迭代数组的元素</span></span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为什么指针变量可以用来标识范围？？？</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="3-5-结构体"><a href="#3-5-结构体" class="headerlink" title="3.5 结构体"></a>3.5 结构体</h4><h5 id="3-5-1-结构体定义"><a href="#3-5-1-结构体定义" class="headerlink" title="3.5.1 结构体定义"></a>3.5.1 结构体定义</h5><p>​    和C语言一样，结构体中可以定义多个不同的数据类型</p><p>type 关键字用于设定结构体的名称  和struct搭配使用，struct定义一个新的数据类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition</span><br><span class="line">   member definition</span><br><span class="line">   ...</span><br><span class="line">   member definition</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义好结构体类型，我们就可以使用结构体声明一个结构体变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br><span class="line"></span><br><span class="line">variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-5-2-访问结构体成员"><a href="#3-5-2-访问结构体成员" class="headerlink" title="3.5.2 访问结构体成员"></a>3.5.2 访问结构体成员</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="type">string</span></span><br><span class="line">   author <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> book1 Books</span><br><span class="line">Book1.title = <span class="string">&quot;Go 语言入门&quot;</span></span><br><span class="line">Book1.author = <span class="string">&quot;mars.hao&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-5-3结构体指针"><a href="#3-5-3结构体指针" class="headerlink" title="3.5.3结构体指针"></a>3.5.3结构体指针</h5><p>​    关于结构体指针的定义和申明同样可以套用前文中讲到的指针的相关定义，从而使用一个指针变量存放一个结构体变量的地址。</p><p>​    定义一个结构体变量的语法：var struct_pointer *Books。</p><p>​    这种指针变量的初始化和上文指针部分的初始化方式相同struct_pointer = &amp;Book1，但是和c语言中有所不同，使用结构体指针访问结构体成员<strong>仍然</strong>使用<u>.操作符</u>。格式如下：struct_pointer.title</p><h4 id="3-6-字符串"><a href="#3-6-字符串" class="headerlink" title="3.6 字符串"></a>3.6 字符串</h4><h5 id="3-6-1-定义"><a href="#3-6-1-定义" class="headerlink" title="3.6.1 定义"></a>3.6.1 定义</h5><p>​    一个字符串是一个不可改变的字节序列，字符串通常是用来存储文本数据，字符串的元素不可修改，是一个只读的字节数组</p><p>String的底层结构如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span></span><br><span class="line">    Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    一个是字节数组，unsigned int ptr ，第二个是字符串的长度，字符串其实是结构体，赋值操作是reflect.StringHeader结构体的复制过程，并不会涉及底层字节数组的复制，所以我们也可以将字符串数组看作一个结构体数组。</p><h5 id="3-6-2-字符串的UTF8编码"><a href="#3-6-2-字符串的UTF8编码" class="headerlink" title="3.6.2 字符串的UTF8编码"></a>3.6.2 字符串的UTF8编码</h5><p>go语言的源文件采用utf8编码</p><p>如果遇到一个错误的编码，生成一个特别的unicode字符’\uFFFD’这个字符在不同的软件中的显示效果可能不太一样，在印刷中这个符号通常是一个黑色六角形或钻石形状，里面包含一个白色的问号‘�’。</p><p>fmt.Println(“\xe4\x00\x00\xe7\x95\x8cabc”) <em>// �界abc</em></p><p>不过在for range迭代这个含有损坏的UTF8字符串时，第一字符的第二和第三字节依然会被单独迭代到，不过此时迭代的值是损坏后的0：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 65533  // \uFFFD, 对应 �</span></span><br><span class="line"><span class="comment">// 1 0      // 空字符</span></span><br><span class="line"><span class="comment">// 2 0      // 空字符</span></span><br><span class="line"><span class="comment">// 3 30028  // 界</span></span><br><span class="line"><span class="comment">// 6 97     // a</span></span><br><span class="line"><span class="comment">// 7 98     // b</span></span><br><span class="line"><span class="comment">// 8 99     // c</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-6-3-强制类型转换"><a href="#3-6-3-强制类型转换" class="headerlink" title="3.6.3 强制类型转换"></a>3.6.3 强制类型转换</h5><p>字符串相关的强制类型转换涉及到[]byte 数组和[] rune两种类型，每个转换都可能隐含重新分配内存的 改价</p><p>字符串和【】rune转换比较特殊，因为一般这种强制类型转换要求两个类型的底层内存结构尽量一致</p><h4 id="3-7-slice"><a href="#3-7-slice" class="headerlink" title="3.7 slice"></a>3.7 slice</h4><p>​    简单地说，切片就是一种简化版的动态数组，动态数组的长度不固定，切片的长度不能成为组成部分</p><p>​    切片的高效操作是为了<u>降低内存分配次数</u> 尽量保证append操作不会超出cap的容量，降低触发内存分配次数和每次分配内存的大小</p><ul><li><h5 id="3-7-1-定义"><a href="#3-7-1-定义" class="headerlink" title="3.7.1 定义"></a>3.7.1 定义</h5></li></ul><p>:walking_man:长度不固定，有一个cap上限</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span>   <span class="comment">// 指向底层的的数组指针</span></span><br><span class="line">    Len  <span class="type">int</span>   <span class="comment">// 切片长度</span></span><br><span class="line">    Cap  <span class="type">int</span>   <span class="comment">// 切片最大长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>和数组一样，内置的len函数返回切片中有效元素的长度，内置的cap函数返回切片容量大小，容量必须大于或等于切片的长度。</p><p>切片可以和<strong>nil</strong>进行比较，只有当切片<strong>底层数据指针为空时</strong>切片本身为nil，这时候<strong>切片的长度和容量信息将是无效的</strong>。如果有切片的底层数据指针为空，但是长度和容量不为0的情况，那么说明切片本身已经被损坏了</p><p>只要是切片的底层数据指针、长度和容量没有发生变化的话，对切片的遍历、元素的读取和修改都和数组是一样的。在对切片本身赋值或参数传递时，和数组指针的操作方式类似，只是复制切片头信息（reflect.SliceHeader），并不会复制底层的数据。对于类型，和数组的最大不同是，切片的类型和长度信息无关，只要是相同类型元素构成的切片均对应相同的切片类型。</p><ul><li><h5 id="3-7-2-添加元素"><a href="#3-7-2-添加元素" class="headerlink" title="3.7.2 添加元素"></a>3.7.2 添加元素</h5></li></ul><p>:happy:使用append（）内置泛型函数，可以向切面中添加元素</p><ol><li>在切片尾部追加N个元素</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>:earth_asia:    注意：尾部添加在容量不足的条件下需要重新分配内存，可能导致巨大的内存分配和复制数据代价。即使容量足够，依然需要用append函数的返回值来更新切片本身，因为新切片的长度已经发生了变化。</p><ol><li>在切片开头追加元素</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">a = <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">0</span>&#125;,a...)</span><br><span class="line">a = <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;,a...)</span><br></pre></td></tr></table></figure><p>:taco: 注意开头会<strong>导致内存重新分配，已有的元素全部复制一次</strong></p><ol><li>append 链式操作</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i],<span class="built_in">append</span>([]<span class="type">int</span>&#123;x&#125;,a[i:]...)...)</span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, a[i:]...)...) <span class="comment">// 在第i个位置插入切片</span></span><br></pre></td></tr></table></figure><ol><li>append和copy组合</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">copy</span>(a[i+<span class="number">1</span>:],a[i:])<span class="comment">//a[i:]向后移动一个位置</span></span><br><span class="line">a[i] = x <span class="comment">//添加新插入</span></span><br></pre></td></tr></table></figure><p>第三个操作会创建一个临时对象，借助copy函数避免这操作</p><ul><li><h5 id="3-7-3-删除元素"><a href="#3-7-3-删除元素" class="headerlink" title="3.7.3 删除元素"></a>3.7.3 删除元素</h5></li></ul><p>根据要删除元素的位置有三种情况：</p><ol><li><p>从开头删除</p><ul><li><p>直接移动指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...&#125;</span><br><span class="line">a = a[<span class="number">1</span>:]                       <span class="comment">// 删除开头1个元素</span></span><br><span class="line">a = a[N:]                       <span class="comment">// 删除开头N个元素</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>将后面的数据向开头移动（使用append完成）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...&#125;</span><br><span class="line">a = a[<span class="number">1</span>:]                       <span class="comment">// 删除开头1个元素</span></span><br><span class="line">a = a[N:]                       <span class="comment">// 删除开头N个元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>copy</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">a = a[:<span class="built_in">copy</span>(a,a[<span class="number">1</span>:])]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>从中间位置删除：</p><p>对于删除中间的元素，需要对剩余的元素挪动，同样可以用append或者copy</p><p>append删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,...&#125;</span><br><span class="line">a = <span class="built_in">append</span>(a[:i],a[i+<span class="number">1</span>],...)</span><br><span class="line">a = <span class="built_in">append</span>(a[:i],a[i+N:],...)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>从尾部删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-8-函数"><a href="#3-8-函数" class="headerlink" title="3.8 函数"></a>3.8 函数</h4><p>在Go语言中，函数有具名和匿名之分</p><ol><li>具名</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a,b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>匿名</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Add = <span class="function"><span class="keyword">func</span><span class="params">(a,b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionName</span><span class="params">([parameter list])</span></span>[<span class="keyword">return</span> <span class="keyword">type</span>]&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th></th><th>解析</th></tr></thead><tbody><tr><td>func</td><td>函数由func开始声明</td></tr><tr><td>function_name</td><td>函数名称</td></tr><tr><td>parameter list</td><td>参数列表</td></tr><tr><td>return_types</td><td>返回类型</td></tr><tr><td>函数体</td><td>函数定义的代码集合</td></tr></tbody></table></div><h5 id="3-7-3-传参"><a href="#3-7-3-传参" class="headerlink" title="3.7.3 传参"></a>3.7.3 传参</h5><p>当可变参数是一个空接口类型时，调用者是否解包可变参数会导致不同的结果，我们解释一下解包的含义，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">Print(a...)   <span class="comment">// 解包</span></span><br><span class="line">Print(a)  <span class="comment">// 未解包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...<span class="type">int</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Println(a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上当传入参数为a…时即是对切片a进行了解包，此时其实相当于直接调用Print(1,2,3)。当传入参数直接为 a时等价于直接调用Print([]int{}{1,2,3})</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go语言基础&quot;&gt;&lt;a href=&quot;#Go语言基础&quot; class=&quot;headerlink&quot; title=&quot;Go语言基础&quot;&gt;&lt;/a&gt;Go语言基础&lt;/h2&gt;&lt;h3 id=&quot;1-Go语言的出现&quot;&gt;&lt;a href=&quot;#1-Go语言的出现&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="daily" scheme="http://example.com/tags/daily/"/>
    
  </entry>
  
  <entry>
    <title>VUE学习</title>
    <link href="http://example.com/posts/0.html"/>
    <id>http://example.com/posts/0.html</id>
    <published>2022-10-27T09:26:12.000Z</published>
    <updated>2022-10-28T06:28:40.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端快速入门"><a href="#前端快速入门" class="headerlink" title="前端快速入门"></a>前端快速入门</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 逻辑</span><br><span class="line">- 判断</span><br><span class="line">- 循环</span><br><span class="line"></span><br><span class="line"># 事件</span><br><span class="line">- 浏览器事件： window document</span><br><span class="line">- DOM事件 : 增 删 改 遍历</span><br><span class="line">- jquery</span><br><span class="line"></span><br><span class="line"># 视图</span><br><span class="line">- html</span><br><span class="line">- css</span><br><span class="line"> </span><br><span class="line"># 通信</span><br><span class="line">- xhr</span><br><span class="line">- ajax（most important）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>好东西</strong>：bootstrap 脚本工具 VUE + BootStrap</p><p>​                —-&gt; java全栈工程师：</p><ul><li>后端 ： java+ssm+maven+springBoot+mybatis</li><li>前端 ： html + css + js +jquery</li><li>运维 ： 项目发布； 服务器如何运行一个项目</li></ul><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>​    </p><p>​        CSS：</p><ul><li><p>预处理器：sess 、现在可以用less（常用）写</p><p>javaScript预处理器</p><p>Javascript</p></li><li><p>TypeScript</p></li><li><p>Jquery ：</p></li><li><p>Angular : 谷歌收购的前端框架，java开发，增加了前端</p></li><li><p>vue</p><ul><li>虚拟dom+angular（模块化开发）</li></ul></li><li><p>react </p><ul><li>facebook 出品，高性能的js框架</li></ul><h2 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h2></li></ul><ul><li><p>三端统一</p><ul><li>混合开发（目的是实验一套代码三端统一）<ul><li>pc + android(.apk) + ios(.ipa)</li><li>打包方式两种<ul><li><ol><li>云打包 hbuild -&gt;hbulidX </li><li>本地打包 cordove</li></ol></li></ul></li></ul></li></ul></li><li><p>前端了解的后端技术</p><ul><li>express ：nodejs框架</li><li>koa：express简化版</li><li>npm项目综合管理工具：类似maven</li><li>yarn：npm的替代方案</li><li></li></ul></li><li><p>饿了么ui</p><ul><li>elementUI是饿了么前端开源的vue UI组件库，主键齐全，基本涵盖后台所需的所有组件，例子很丰富，主要用于开发pc的页面，是一个质量比较高的vueUI组件库</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端快速入门&quot;&gt;&lt;a href=&quot;#前端快速入门&quot; class=&quot;headerlink&quot; title=&quot;前端快速入门&quot;&gt;&lt;/a&gt;前端快速入门&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    
    <category term="daily" scheme="http://example.com/tags/daily/"/>
    
  </entry>
  
  <entry>
    <title>springboot_generate_redis</title>
    <link href="http://example.com/posts/b7fc.html"/>
    <id>http://example.com/posts/b7fc.html</id>
    <published>2022-10-24T06:37:12.000Z</published>
    <updated>2022-10-28T06:28:00.889Z</updated>
    
    
    
    
    
    <category term="daily" scheme="http://example.com/tags/daily/"/>
    
  </entry>
  
  <entry>
    <title>redis事务</title>
    <link href="http://example.com/posts/3eeb.html"/>
    <id>http://example.com/posts/3eeb.html</id>
    <published>2022-10-24T05:59:17.945Z</published>
    <updated>2022-10-28T06:26:44.766Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><ul><li><blockquote><p>​    本质 一组命令的集合</p></blockquote><ul><li><pre><code class="lang-bash">一个事务中的所有命令都会被数列话，在事务执行过程中会按照顺序执行，一次性、顺序性、排他性</code></pre></li><li><p>队列 set set set执行</p></li><li><p>redis单挑命令是保存原子性的，但是事务不保证原子性</p></li><li><p>redis的事务</p><ul><li>\1. 开启事务**（Multi）</li><li>\2. 命令入队 (他会提示queued)</li><li>\3. 执行事务** （exec）</li><li>\4. 放弃（取消）事务 （discard）</li></ul></li><li><p>redis可以实现乐观锁</p><ul><li>悲观锁<ul><li>很悲观，认为什么时候都会出现问题，无论做什么都会被枷锁</li></ul></li><li>乐观锁‘<ul><li>很乐观，认为什么时候都不会出现问题，所以不会上锁，更新数据的时候去判断一下看看是否数据被修改</li><li>获取version</li><li>更新的时候比较version</li><li>redis中的watch监视变量就是一个乐观锁</li></ul></li></ul></li><li><p>如果命令有错</p><ul><li>编译型异常（代码有问题），食物中所有的命令都不会被执行 #在事务队列里面的都不会运行</li><li>运行时异常（1/0  runtime ERROR），如果事务队列中存在语法性错误，其他命令时可以正常执行的，错误命令不会执行 #</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Redis事务&quot;&gt;&lt;a href=&quot;#Redis事务&quot; class=&quot;headerlink&quot; title=&quot;Redis事务&quot;&gt;&lt;/a&gt;Redis事务&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;blockquote&gt;
&lt;p&gt;​    本质 一组命令的集合&lt;/p&gt;
&lt;/blockq</summary>
      
    
    
    
    
  </entry>
  
</feed>
