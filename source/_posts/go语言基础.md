---
title: 'go语言学习'
abbrlink: 3dsd
date: 2022-10-27 17:26:12
tags: daily
cover: https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fmobile%2F2020-04-01%2F5e8423d5e080e.jpg&refer=http%3A%2F%2Fpic1.win4000.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1669530272&t=4f61b46fe5b9b5c01d4d542c7d2c1966
keywords: daily
---
## Go语言基础



### 1. Go语言的出现

​	在具体学习go语言的基础语法之前，我们来了解一下go语言出现的时机及其特点。

​	Go语言最初由Google公司的Robert Griesemer、Ken Thompson和Rob Pike三个大牛于2007年开始设计发明，他们最终的目标是设计一种适应网络和多核时代的C语言。所以Go语言很多时候被描述为“类C语言”，或者是“21世纪的C语言”，当然从各种角度看，Go语言确实是从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等诸多编程思想。但是Go语言更是对C语言最彻底的一次扬弃，它舍弃了C语言中灵活但是危险的指针运算，还重新设计了C语言中部分不太合理运算符的优先级，并在很多细微的地方都做了必要的打磨和改变。

### 2. Go版本的Hello World

![image-20230731230057471](https://cdn.kaison.top/img/blog/20230731230059.png)

和C语言类似

#### go语言的基本组成

	- 包声名 package main
	- 引入包 import "fmt"
	- 函数 
	- 变量 可以由字母、数字、下划线，但开头不能为数字
	- 语句/表达式，一行代表一个语句结束
	- 注释 //  /**/

### 3. 数据类型

####  3.1 基本数据类型

![image-20230731232031659](https://cdn.kaison.top/img/blog/20230731232032.png)

####  3.2 定义变量

格式为var identifier typename

##### 	**如果变量没有初始化**

在go语言中定义了一个变量，指定变量类型，如果没有初始化，则变量默认为零值。**零值就是变量没有做初始化时系统默认设置的值**。

| 类型     | 零值           |
| -------- | -------------- |
| 数值类型 | 0              |
| 布尔类型 | false          |
| 字符串   | “”（空字符串） |

##### 	如果变量没有指定类型

在go语言中没有指定类型，可以通过变量初始值来判断

```go
package main
import "fmt"
func main(){
    var d = true;
    fmt.Println(d)
}
```

#####  	:= 符号

声明语句 相对于构造器，只能用一次

```go
typename := value

//相当于

var intVal := 1
intVal = 1
```

##### 多变量声名

```go
var x,y int
var c,d int = 1,2
g,h := 123,"hello"

var(
	a int
    b bool
)
```

##### 匿名变量

在变量声明的时候使用下划线代替即可

```go
func GetData()(int ,int){
    return 10,20
}
func main(){
    a, _ :=GetData()
    _, b :=GetData()
    fmt.Println(a,b)
}//匿名变量不占用内存空间
```

变量作用域

作用域指的是已声明的标识符所表示的常量、类型、函数或者包在源代码中的作用范围，在此我们主要看一下go中变量的作用域，根据变量定义位置的不同，可以分为一下三个类型：

    函数内定义的变量为局部变量，这种局部变量的作用域只在函数体内，函数的参数和返回值变量都属于局部变量。这种变量在存在于函数被调用时，销毁于函数调用结束后。
    
    函数外定义的变量为全局变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，甚至可以使用import引入外部包来使用。全局变量声明必须以 var 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。
    
    函数定义中的变量成为形式参数，定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。形式参数会作为函数的局部变量来使用。
#### 3.3 基本类型

![image-20230801000632419](https://cdn.kaison.top/img/blog/20230801000633.png)

#### 3.4 指针

Go语言中的取地址符&，放到一个变量前取其地址

##### 3.4.1 指针声明和优化

​	和基础类型数据相同，在使用指针变量之前我们首先需要声明指针 var var_name *var_type

```go
   var a int= 20   /* 声明实际变量 */
   var ip *int        /* 声明指针变量 */

   ip = &a  /* 指针变量的存储地址 */

```

##### 3.4.2 空指针

​	值为nil，没有分配任何变量



##### 3.4.3 数组

​	和c语言相通，数组是具有相同唯一类型的一组以编号且长度固定的数据项序列



###### 3.4.3.1 数组声明

​	Go的语法如下

  	var variable_name[size] variable_TYPE

```go
var balance [10] float32

```

###### 3.4.3.2 初始化数组

数组初始化有几种

1. 直接进行初始化：`var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}`

2. 通过字面量在声明数组的同时快速初始化数组：`balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}`

3. 数组长度不确定，编译器通过元素个数自行推断数组长度，在[ ]中填入...，举例如下：var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}和balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}

4. 数组长度确定，指定下标进行部分初始化：`balanced := [5]float32(1:2.0, 3:7.0)`

   ###### 3.4.3.3数组指针

   ```go
   var a = [...]int{1, 2, 3} // a 是一个数组
   var b = &a                // b 是指向数组的指针
   
   //数组指针除了可以防止数组作为参数传递的时候浪费空间，还可以利用其和for range来遍历数组，具体代码如下：
   for i, v := range b {     // 通过数组指针迭代数组的元素
       fmt.Println(i, v)
   }
   
   //为什么指针变量可以用来标识范围？？？
   ```

   

#### 3.5 结构体



##### 3.5.1 结构体定义

​	和C语言一样，结构体中可以定义多个不同的数据类型

type 关键字用于设定结构体的名称  和struct搭配使用，struct定义一个新的数据类型

```go
type struct_variable_type struct {
   member definition
   member definition
   ...
   member definition
}

```

定义好结构体类型，我们就可以使用结构体声明一个结构体变量

```go
variable_name := structure_variable_type {value1, value2...valuen}

variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen}

```

##### 3.5.2 访问结构体成员

```go
package main

import "fmt"

type Books struct {
   title string
   author string
}

func main() {
	var book1 Books
	Book1.title = "Go 语言入门"
	Book1.author = "mars.hao"	
}

```

##### 3.5.3结构体指针

​	关于结构体指针的定义和申明同样可以套用前文中讲到的指针的相关定义，从而使用一个指针变量存放一个结构体变量的地址。

​	定义一个结构体变量的语法：var struct_pointer *Books。

​	这种指针变量的初始化和上文指针部分的初始化方式相同struct_pointer = &Book1，但是和c语言中有所不同，使用结构体指针访问结构体成员**仍然**使用<u>.操作符</u>。格式如下：struct_pointer.title


#### 3.6 字符串

##### 3.6.1 定义

​	一个字符串是一个不可改变的字节序列，字符串通常是用来存储文本数据，字符串的元素不可修改，是一个只读的字节数组

String的底层结构如下

```go
type StringHeader struct {
    Data uintptr
    Len  int
}
```

​	一个是字节数组，unsigned int ptr ，第二个是字符串的长度，字符串其实是结构体，赋值操作是reflect.StringHeader结构体的复制过程，并不会涉及底层字节数组的复制，所以我们也可以将字符串数组看作一个结构体数组。

##### 3.6.2 字符串的UTF8编码

go语言的源文件采用utf8编码

如果遇到一个错误的编码，生成一个特别的unicode字符'\uFFFD'这个字符在不同的软件中的显示效果可能不太一样，在印刷中这个符号通常是一个黑色六角形或钻石形状，里面包含一个白色的问号‘�’。

fmt.Println("\xe4\x00\x00\xe7\x95\x8cabc") *// �界abc*

不过在for range迭代这个含有损坏的UTF8字符串时，第一字符的第二和第三字节依然会被单独迭代到，不过此时迭代的值是损坏后的0：

```go
// 0 65533  // \uFFFD, 对应 �
// 1 0      // 空字符
// 2 0      // 空字符
// 3 30028  // 界
// 6 97     // a
// 7 98     // b
// 8 99     // c

```

##### 3.6.3 强制类型转换

字符串相关的强制类型转换涉及到[]byte 数组和[] rune两种类型，每个转换都可能隐含重新分配内存的 改价

字符串和【】rune转换比较特殊，因为一般这种强制类型转换要求两个类型的底层内存结构尽量一致



#### 3.7 slice

​	简单地说，切片就是一种简化版的动态数组，动态数组的长度不固定，切片的长度不能成为组成部分

​	切片的高效操作是为了<u>降低内存分配次数</u> 尽量保证append操作不会超出cap的容量，降低触发内存分配次数和每次分配内存的大小



- ##### 3.7.1 定义

:walking_man:长度不固定，有一个cap上限

```go
type SliceHeader struct {
    Data uintptr   // 指向底层的的数组指针
    Len  int	   // 切片长度
    Cap  int	   // 切片最大长度
}

```

和数组一样，内置的len函数返回切片中有效元素的长度，内置的cap函数返回切片容量大小，容量必须大于或等于切片的长度。

切片可以和**nil**进行比较，只有当切片**底层数据指针为空时**切片本身为nil，这时候**切片的长度和容量信息将是无效的**。如果有切片的底层数据指针为空，但是长度和容量不为0的情况，那么说明切片本身已经被损坏了

只要是切片的底层数据指针、长度和容量没有发生变化的话，对切片的遍历、元素的读取和修改都和数组是一样的。在对切片本身赋值或参数传递时，和数组指针的操作方式类似，只是复制切片头信息（reflect.SliceHeader），并不会复制底层的数据。对于类型，和数组的最大不同是，切片的类型和长度信息无关，只要是相同类型元素构成的切片均对应相同的切片类型。



- ##### 3.7.2 添加元素

:happy:使用append（）内置泛型函数，可以向切面中添加元素

1. 在切片尾部追加N个元素

```go
var a []int
a = append(a,1)
```

:earth_asia:	注意：尾部添加在容量不足的条件下需要重新分配内存，可能导致巨大的内存分配和复制数据代价。即使容量足够，依然需要用append函数的返回值来更新切片本身，因为新切片的长度已经发生了变化。

 



2. 在切片开头追加元素

```go
var a = []int{1,2,3}
a = append([]int{0},a...)
a = append([]int{-3,-2,-1},a...)
```

:taco: 注意开头会**导致内存重新分配，已有的元素全部复制一次**



3. append 链式操作

```go
var a []int
a = append(a[:i],append([]int{x},a[i:]...)...)
a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片
```



4. append和copy组合

```go
a = append(a,0)
copy(a[i+1:],a[i:])//a[i:]向后移动一个位置
a[i] = x //添加新插入
```

第三个操作会创建一个临时对象，借助copy函数避免这操作

- ##### 3.7.3 删除元素

根据要删除元素的位置有三种情况：

1. 从开头删除

   - 直接移动指针

     ```go
     a = []int{1, 2, 3, ...}
     a = a[1:]                       // 删除开头1个元素
     a = a[N:]                       // 删除开头N个元素
     
     
     ```

   - 将后面的数据向开头移动（使用append完成）

     ```go
     a = []int{1, 2, 3, ...}
     a = a[1:]                       // 删除开头1个元素
     a = a[N:]                       // 删除开头N个元素
     
     ```

   - copy

     ```go
     a = []int{1,2,3}
     a = a[:copy(a,a[1:])]
     ```

2. 从中间位置删除：

   对于删除中间的元素，需要对剩余的元素挪动，同样可以用append或者copy

   append删除

   ```go
   a = []int{1,2,3,...}
   a = append(a[:i],a[i+1],...)
   a = append(a[:i],a[i+N:],...)
   
   ```

3. 从尾部删除

   ```go
   a = []int{1,2,3}
   a = a[:len(a)-1]
   ```

#### 3.8 函数

在Go语言中，函数有具名和匿名之分



1. 具名

```go
func Add(a,b int) int{
    return a+b
}
```



2. 匿名

```go
var Add = func(a,b int) int {
    return a+b
}
```



函数的定义如下

```go
func functionName([parameter list])[return type]{
    //函数体
}
```

|                | 解析               |
| -------------- | ------------------ |
| func           | 函数由func开始声明 |
| function_name  | 函数名称           |
| parameter list | 参数列表           |
| return_types   | 返回类型           |
| 函数体         | 函数定义的代码集合 |



##### 3.7.3 传参

当可变参数是一个空接口类型时，调用者是否解包可变参数会导致不同的结果，我们解释一下解包的含义，代码如下：

```go
func main(){
	var a = []int{1, 2, 3}
	Print(a...)   // 解包
	Print(a)	  // 未解包
}

func Print(a ...int{}) {
	fmt.Println(a...)
}
```



以上当传入参数为a...时即是对切片a进行了解包，此时其实相当于直接调用Print(1,2,3)。当传入参数直接为 a时等价于直接调用Print([]int{}{1,2,3})